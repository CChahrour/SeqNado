"""
Tests for GitHub Actions automation scripts.

This module tests the scripts in .github/scripts/:
- generate_environments.py: Auto-generates conda environment files from pyproject.toml
- update_bioconda_recipe.py: Updates bioconda recipe meta.yaml with proper Jinja2 handling
"""

import pytest
import tempfile
from pathlib import Path
import sys
import yaml
import shutil
import os

# Add the scripts directory to path
sys.path.insert(0, str(Path(__file__).parent.parent.parent / ".github" / "scripts"))

from generate_environments import (
    parse_pyproject,
    separate_conda_and_pip,
    normalize_dep,
    generate_environment_yml,
    generate_environment_minimal_yml,
    generate_testing_yml,
)

from update_bioconda_recipe import (
    extract_jinja2_and_yaml,
    replace_jinja_expressions,
    restore_jinja_expressions,
    update_meta_yaml,
)

# Test output directory
TEST_OUTPUT_DIR = Path(__file__).parent.parent.parent / "test_output"


@pytest.fixture
def test_dir(request):
    """Create a test directory in test_output/ for this test."""
    test_name = request.node.name
    tmpdir = TEST_OUTPUT_DIR / test_name
    tmpdir.mkdir(parents=True, exist_ok=True)
    
    # Clean it first
    for item in tmpdir.iterdir():
        if item.is_dir():
            shutil.rmtree(item)
        else:
            item.unlink()
    
    yield tmpdir
    
    # Don't delete - keep for inspection


# ============================================================================
# Tests for generate_environments.py
# ============================================================================

class TestParseProject:
    """Test pyproject.toml parsing."""

    def test_parse_real_pyproject(self):
        """Should parse the actual pyproject.toml correctly."""
        core_deps, slurm_deps, py_req = parse_pyproject()
        
        assert len(core_deps) > 0, "Should find core dependencies"
        assert py_req == ">=3.10", "Should find Python requirement"
        
        # Check for expected core deps
        dep_strs = [str(d) for d in core_deps]
        assert any("snakemake" in d for d in dep_strs), "Should have snakemake"
        assert any("numpy" in d for d in dep_strs), "Should have numpy"
        assert any("pandas" in d for d in dep_strs), "Should have pandas"


class TestDependencySeparation:
    """Test separating conda vs pip dependencies."""
    
    def test_separate_tracknado_to_pip(self):
        """tracknado should be in pip_only."""
        deps = [
            "numpy>=1.24,<=2.1.0",
            "tracknado>=0.3.1,<1.0.0",
            "pandas>=2.0",
        ]
        conda_deps, pip_deps = separate_conda_and_pip(deps)
        
        assert "tracknado>=0.3.1,<1.0.0" in pip_deps
        assert "numpy>=1.24,<=2.1.0" in conda_deps
        assert "pandas>=2.0" in conda_deps
    
    def test_separate_mccnado_to_pip(self):
        """mccnado should be in pip_only."""
        deps = ["mccnado", "numpy"]
        conda_deps, pip_deps = separate_conda_and_pip(deps)
        
        assert "mccnado" in pip_deps
        assert "numpy" in conda_deps


class TestGenerateEnvironmentYml:
    """Test environment.yml generation."""
    
    def test_generates_valid_yaml(self):
        """Generated file should be valid YAML."""
        with tempfile.TemporaryDirectory() as tmpdir:
            tmpdir = Path(tmpdir)
            
            core_deps = [
                "numpy>=1.24,<=2.1.0",
                "pandas>=2.0,<=2.3.3",
                "snakemake>=9.12.0,<=9.14.5",
            ]
            
            generate_environment_yml(core_deps, ">=3.10", tmpdir / "environment.yml")
            
            # Should be valid YAML
            with open(tmpdir / "environment.yml") as f:
                content = yaml.safe_load(f)
            
            assert content["name"] == "seqnado"
            assert "conda-forge" in content["channels"]
            assert "python>=3.10" in content["dependencies"]
    
    def test_includes_bioinformatics_tools(self):
        """Should include bioinformatics tools section."""
        with tempfile.TemporaryDirectory() as tmpdir:
            tmpdir = Path(tmpdir)
            
            generate_environment_yml([], ">=3.10", tmpdir / "environment.yml")
            
            with open(tmpdir / "environment.yml") as f:
                content = f.read()
            
            assert "bedtools" in content
            assert "samtools" in content
            assert "fastqc" in content
    
    def test_marks_as_autogenerated(self):
        """Should mark file as auto-generated."""
        with tempfile.TemporaryDirectory() as tmpdir:
            tmpdir = Path(tmpdir)
            
            generate_environment_yml([], ">=3.10", tmpdir / "environment.yml")
            
            with open(tmpdir / "environment.yml") as f:
                first_line = f.readline()
            
            assert "auto-generated" in first_line


class TestGenerateEnvironmentMinimalYml:
    """Test environment_minimal.yml generation."""
    
    def test_includes_only_essential_conda(self):
        """Should only include essential conda packages."""
        with tempfile.TemporaryDirectory() as tmpdir:
            tmpdir = Path(tmpdir)
            
            core_deps = [
                "numpy>=1.24,<=2.1.0",
                "pandas>=2.0,<=2.3.3",
                "snakemake>=9.12.0,<=9.14.5",
                "rich<=14.2.0",
                "pyyaml<=6.0.3",
            ]
            
            generate_environment_minimal_yml(core_deps, ">=3.10", tmpdir / "environment_minimal.yml")
            
            with open(tmpdir / "environment_minimal.yml") as f:
                content = yaml.safe_load(f)
            
            # Should have essential packages
            deps_str = str(content["dependencies"])
            assert "numpy" in deps_str
            assert "pandas" in deps_str
            assert "snakemake" in deps_str
    
    def test_has_minimal_scope(self):
        """Minimal env should be smaller than full env."""
        with tempfile.TemporaryDirectory() as tmpdir:
            tmpdir = Path(tmpdir)
            
            core_deps = [
                "numpy>=1.24,<=2.1.0",
                "pandas>=2.0,<=2.3.3",
                "snakemake>=9.12.0,<=9.14.5",
                "rich<=14.2.0",
                "pyyaml<=6.0.3",
            ]
            
            generate_environment_yml(core_deps, ">=3.10", tmpdir / "env_full.yml")
            generate_environment_minimal_yml(core_deps, ">=3.10", tmpdir / "env_minimal.yml")
            
            with open(tmpdir / "env_full.yml") as f:
                full = yaml.safe_load(f)
            with open(tmpdir / "env_minimal.yml") as f:
                minimal = yaml.safe_load(f)
            
            # minimal should have fewer dependencies
            assert len(minimal["dependencies"]) < len(full["dependencies"])


class TestGenerateTestingYml:
    """Test testing.yml generation."""
    
    def test_includes_pytest_tools(self):
        """Should include pytest and related tools."""
        with tempfile.TemporaryDirectory() as tmpdir:
            tmpdir = Path(tmpdir)
            
            generate_testing_yml([], ">=3.10", tmpdir / "testing.yml")
            
            with open(tmpdir / "testing.yml") as f:
                content = yaml.safe_load(f)
            
            deps_str = str(content["dependencies"])
            assert "pytest" in deps_str
            assert "pytest-cov" in deps_str
            assert "pytest-xdist" in deps_str
    
    def test_includes_core_deps(self):
        """Should include core dependencies."""
        with tempfile.TemporaryDirectory() as tmpdir:
            tmpdir = Path(tmpdir)
            
            core_deps = [
                "numpy>=1.24,<=2.1.0",
                "snakemake>=9.12.0,<=9.14.5",
            ]
            
            generate_testing_yml(core_deps, ">=3.10", tmpdir / "testing.yml")
            
            with open(tmpdir / "testing.yml") as f:
                content = yaml.safe_load(f)
            
            deps_str = str(content["dependencies"])
            assert "numpy" in deps_str
            assert "snakemake" in deps_str


class TestNormalizeDep:
    """Test dependency normalization."""
    
    def test_normalize_with_versions(self):
        """Should normalize dependency with version constraints."""
        name, spec = normalize_dep("numpy>=1.24,<=2.1.0")
        
        assert name == "numpy"
        assert "numpy" in spec
        assert ">=" in spec
    
    def test_normalize_simple(self):
        """Should handle simple dependency names."""
        name, spec = normalize_dep("pytest")
        
        assert name == "pytest"
        assert spec == "pytest"


class TestGenerateEnvironmentsIntegration:
    """Integration tests for environment generation."""
    
    def test_all_generated_files_are_valid_yaml(self):
        """All generated environment files should be valid YAML."""
        with tempfile.TemporaryDirectory() as tmpdir:
            tmpdir = Path(tmpdir)
            
            core_deps, _, py_req = parse_pyproject()
            
            # Generate all files
            generate_environment_yml(core_deps, py_req, tmpdir / "environment.yml")
            generate_environment_minimal_yml(core_deps, py_req, tmpdir / "environment_minimal.yml")
            generate_testing_yml(core_deps, py_req, tmpdir / "testing.yml")
            
            # All should be valid YAML
            for yml_file in [
                tmpdir / "environment.yml",
                tmpdir / "environment_minimal.yml",
                tmpdir / "testing.yml",
            ]:
                with open(yml_file) as f:
                    data = yaml.safe_load(f)
                
                assert isinstance(data, dict), f"{yml_file} should parse to dict"
                assert "name" in data, f"{yml_file} should have 'name'"
                assert "channels" in data, f"{yml_file} should have 'channels'"
                assert "dependencies" in data, f"{yml_file} should have 'dependencies'"
    
    def test_all_files_have_python_requirement(self):
        """All files should include Python version requirement."""
        with tempfile.TemporaryDirectory() as tmpdir:
            tmpdir = Path(tmpdir)
            
            _, _, py_req = parse_pyproject()
            core_deps = ["numpy>=1.24,<=2.1.0"]
            
            generate_environment_yml(core_deps, py_req, tmpdir / "environment.yml")
            generate_environment_minimal_yml(core_deps, py_req, tmpdir / "environment_minimal.yml")
            generate_testing_yml(core_deps, py_req, tmpdir / "testing.yml")
            
            for yml_file in [
                tmpdir / "environment.yml",
                tmpdir / "environment_minimal.yml",
                tmpdir / "testing.yml",
            ]:
                with open(yml_file) as f:
                    content = f.read()
                
                assert f"python{py_req}" in content, f"{yml_file} should include Python requirement"


# ============================================================================
# Tests for update_bioconda_recipe.py
# ============================================================================

class TestJinja2Extraction:
    """Test Jinja2 statement extraction from raw content."""
    
    def test_extract_jinja2_statements(self):
        """Should extract {% set ... %} statements."""
        content = '''{% set version = "1.0.0" %}
{% set build = "0" %}
package:
  name: seqnado
  version: {{ version }}
'''
        jinja_lines, yaml_content = extract_jinja2_and_yaml(content)
        
        assert len(jinja_lines) == 2
        assert 'version = "1.0.0"' in jinja_lines[0]
        assert 'build = "0"' in jinja_lines[1]
        assert "package:" in yaml_content
        assert "version: {{ version }}" in yaml_content
    
    def test_extract_no_jinja2(self):
        """Should handle content with no Jinja2 statements."""
        content = '''package:
  name: seqnado
  version: 1.0.0
'''
        jinja_lines, yaml_content = extract_jinja2_and_yaml(content)
        
        assert len(jinja_lines) == 0
        assert "package:" in yaml_content
    
    def test_extract_mixed_content(self):
        """Should handle mixed Jinja2 and YAML lines."""
        content = '''{% set version = "1.0.0" %}
package:
  name: seqnado
  version: {{ version }}
requirements:
  run:
    - python
'''
        jinja_lines, yaml_content = extract_jinja2_and_yaml(content)
        
        assert len(jinja_lines) == 1
        assert "python" in yaml_content
        assert "package:" in yaml_content


class TestJinja2ExpressionHandling:
    """Test replacement and restoration of Jinja2 expressions."""
    
    def test_replace_jinja_expressions(self):
        """Should replace {{ ... }} with placeholders."""
        yaml_content = "version: {{ version }}\nbuild: {{ build }}"
        
        modified, placeholders = replace_jinja_expressions(yaml_content)
        
        assert "__JINJA_0__" in modified
        assert "__JINJA_1__" in modified
        assert "{{ version }}" in placeholders.values()
        assert "{{ build }}" in placeholders.values()
    
    def test_replace_no_expressions(self):
        """Should handle content with no Jinja2 expressions."""
        yaml_content = "version: 1.0.0\nbuild: 0"
        
        modified, placeholders = replace_jinja_expressions(yaml_content)
        
        assert modified == yaml_content
        assert len(placeholders) == 0
    
    def test_restore_jinja_expressions(self):
        """Should restore expressions from placeholders."""
        text = "version: __JINJA_0__\nbuild: __JINJA_1__"
        placeholders = {
            "__JINJA_0__": "{{ version }}",
            "__JINJA_1__": "{{ build }}"
        }
        
        restored = restore_jinja_expressions(text, placeholders)
        
        assert "{{ version }}" in restored
        assert "{{ build }}" in restored
    
    def test_roundtrip_expressions(self):
        """Should preserve expressions through replace and restore."""
        original = "version: {{ version }}\nbuild: {{ build }}"
        
        modified, placeholders = replace_jinja_expressions(original)
        restored = restore_jinja_expressions(modified, placeholders)
        
        assert restored == original


class TestUpdateMetaYaml:
    """Test the full meta.yaml update function."""
    
    def test_update_basic_meta_yaml(self, test_dir):
        """Should update version, SHA256, and dependencies."""
        tmpdir = test_dir
        
        # Create meta.yaml
        meta_yaml = tmpdir / "meta.yaml"
        meta_yaml.write_text("""package:
  name: seqnado
  version: 1.0.0
source:
  sha256: old_hash
requirements:
  run:
    - python >=3.10
    - snakemake >8,<9
""")
        
        # Create meta_deps.txt
        meta_deps = tmpdir / "meta_deps.txt"
        meta_deps.write_text("""- python >=3.10
- snakemake >=9.12.0,<=9.14.5
- numpy >=1.24,<=2.1.0
""")
        
        # Change to temp directory and run update
        original_cwd = os.getcwd()
        try:
            os.chdir(tmpdir)
            update_meta_yaml("1.0.1", "new_hash_abc123", str(meta_deps))
        finally:
            os.chdir(original_cwd)
        
        # Verify updates
        updated = meta_yaml.read_text()
        assert "version: 1.0.1" in updated
        assert "sha256: new_hash_abc123" in updated
        assert "snakemake >=9.12.0,<=9.14.5" in updated
        assert "numpy >=1.24,<=2.1.0" in updated
        assert "snakemake >8,<9" not in updated
    
    def test_update_preserves_jinja2(self, test_dir):
        """Should preserve Jinja2 templating."""
        tmpdir = test_dir
        
        # Create meta.yaml with Jinja2
        meta_yaml = tmpdir / "meta.yaml"
        meta_yaml.write_text("""{% set version = "1.0.0" %}
package:
  name: seqnado
  version: {{ version }}
source:
  sha256: old_hash
  url: https://pypi.io/packages/source/s/seqnado/seqnado-{{ version }}.tar.gz
requirements:
  build:
    - {{ compiler('c') }}
  run:
    - python >=3.10
""")
        
        # Create meta_deps.txt
        meta_deps = tmpdir / "meta_deps.txt"
        meta_deps.write_text("- python >=3.10\n- numpy >=1.24,<=2.1.0\n")
        
        # Update
        original_cwd = os.getcwd()
        try:
            os.chdir(tmpdir)
            update_meta_yaml("1.0.1", "new_hash", str(meta_deps))
        finally:
            os.chdir(original_cwd)
        
        # Verify Jinja2 is preserved
        updated = meta_yaml.read_text()
        assert "{% set version" in updated
        assert "{{ version }}" in updated
        assert "{{ compiler('c') }}" in updated
        assert "version: 1.0.1" in updated  # Version should be updated in Jinja2
    
    def test_missing_meta_yaml_raises(self, test_dir):
        """Should raise FileNotFoundError if meta.yaml missing."""
        tmpdir = test_dir
        
        meta_deps = tmpdir / "meta_deps.txt"
        meta_deps.write_text("- python\n")
        
        original_cwd = os.getcwd()
        try:
            os.chdir(tmpdir)
            with pytest.raises(FileNotFoundError):
                update_meta_yaml("1.0.1", "hash", str(meta_deps))
        finally:
            os.chdir(original_cwd)
    
    def test_missing_meta_deps_raises(self, test_dir):
        """Should raise FileNotFoundError if meta_deps.txt missing."""
        tmpdir = test_dir
        
        meta_yaml = tmpdir / "meta.yaml"
        meta_yaml.write_text("package:\n  name: test\n")
        
        original_cwd = os.getcwd()
        try:
            os.chdir(tmpdir)
            with pytest.raises(FileNotFoundError):
                update_meta_yaml("1.0.1", "hash", "/nonexistent/meta_deps.txt")
        finally:
            os.chdir(original_cwd)
    
    def test_update_handles_dash_prefix_in_deps(self, test_dir):
        """Should handle deps with '- ' prefix in meta_deps.txt."""
        tmpdir = test_dir
        
        meta_yaml = tmpdir / "meta.yaml"
        meta_yaml.write_text("""package:
  name: seqnado
  version: 1.0.0
source:
  sha256: old
requirements:
  run:
    - python
""")
        
        meta_deps = tmpdir / "meta_deps.txt"
        meta_deps.write_text("- python >=3.10\n- numpy\n")
        
        original_cwd = os.getcwd()
        try:
            os.chdir(tmpdir)
            update_meta_yaml("1.0.1", "hash", str(meta_deps))
        finally:
            os.chdir(original_cwd)
        
        updated = meta_yaml.read_text()
        assert "- python >=3.10" in updated
        assert "- numpy" in updated


class TestBiocondaIntegration:
    """Integration tests for bioconda recipe updates."""
    
    def test_complete_update_workflow(self, test_dir):
        """Should handle realistic bioconda meta.yaml update."""
        tmpdir = test_dir
        
        # Create realistic meta.yaml similar to bioconda
        meta_yaml = tmpdir / "meta.yaml"
        meta_yaml.write_text("""{% set version = "1.0.0" %}
{% set build = "0" %}

package:
  name: seqnado
  version: {{ version }}

source:
  url: https://pypi.io/packages/source/s/seqnado/seqnado-{{ version }}.tar.gz
  sha256: abc123def456

build:
  number: {{ build }}
  noarch: python

requirements:
  build:
    - python >=3.10
    - pip
  host:
    - python >=3.10
    - pip
  run:
    - python >=3.10
    - snakemake >8,<9
    - pyyaml
""")
        
        meta_deps = tmpdir / "meta_deps.txt"
        meta_deps.write_text("""- python >=3.10
- snakemake >=9.12.0,<=9.14.5
- pyyaml
- numpy >=1.24,<=2.1.0
- pandas >=2.0,<=2.3.3
""")
        
        original_cwd = os.getcwd()
        try:
            os.chdir(tmpdir)
            update_meta_yaml("1.0.1", "xyz789uvw", str(meta_deps))
        finally:
            os.chdir(original_cwd)
        
        updated = meta_yaml.read_text()
        
        # Verify all updates
        assert "version = \"1.0.1\"" in updated  # Jinja2 version updated
        assert "version: 1.0.1" in updated  # YAML version updated
        assert "sha256: xyz789uvw" in updated
        assert "snakemake >=9.12.0,<=9.14.5" in updated
        assert "numpy >=1.24,<=2.1.0" in updated
        assert "pandas >=2.0,<=2.3.3" in updated
        assert "snakemake >8,<9" not in updated
        
        # Verify Jinja2 still works
        assert "{% set version" in updated
        assert "{{ version }}" in updated
